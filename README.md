# eveningdriver
### Streaming webhook ETL

eveningdriver is a simple ETL tool operating on JSON data, streaming events
through a series of transformations. Incoming data is received from webhooks
or generated by scheduled transforms, then passed along a chain of transforms.

eveningdriver uses redis as a backend to provide a reliable, atomic queue
of events to be processed. The event-driven model allows each step to run
independently across processes or machines, allowing the system to scale
as far as the queue will.

## Build
To build eveningdriver, clone the repository and run:
```
npm install
gulp
```
The source will be compiled into `target/main`.

*TODO*: add a single-file packaged version (webpack-style).

## Configure
The configuration file included with eveningdriver defines a single
transform, which logs all incoming events. You can copy and modify the
config file to add more transforms, shared data, and set the correct
connections for your environment.

## Run
To run eveningdriver, you need to specify the directory in which
`config.json` may be found:
```
EVD_ROOT="~/evd" node target/main/main.js
```

## Event Flow
New events are created from requests to the webhook API or by scheduled
generators. The request body and query parameters or the generator's
template are used as the event payload.

The other transforms in the chain listen for events to be created. When a
new event is created targeting that transform, the `process` method is
called. The transform may emit a new event with the same or modified data,
emit nothing, or fail with an error.

Transforms run asynchronously and can do almost anything internally. The
most common scenario is to render a template using data from the incoming
event, but HTTP requests can be made, logic and conditions applied, or
almost anything else.

## Transforms
Each transform inherits from the `Transform` class and implements a
`process` method. This method takes event data (and optionally the event
ID) and must return a promise.

If the promise resolves with some object, that will become a new event
and will be sent to any transforms listing the current one as an input.

If the promise resolves with anything else (null or not an object), no
new event will be created.

If the promise rejects, any error will be logged and the current event
may be retried, depending on configuration settings.

## Templates
Almost every option in a transform may be a template. Templates use the
Handlebars library, which replaces `{{tokens}}` with the appropriate
data from the incoming event.

If the body of a transform uses a template, the output of that template
must be valid JSON and will be parsed before the transform resolves.

### Files
Rather than defining a template in the config file (which can be a pain,
thanks to escaping quotes), you may use a string starting with `file://`
to load a file from the local system. Template files do not require
quotes or other JSON special characters to be escaped.

The `${root}` token may be used in file paths and will be replaced with
the current root directory for the application (the value of `EVD_ROOT`).

### Path Helper
Within templates, the `{{path path data}}` helper may be used to run
JSONpath lookups on the incoming event.

The `path` parameter should be a valid JSONpath pattern (preferably
quoted).

The `data` parameter should be a Handlebars reference to part of the
current event. `this` will refer to the event payload, unless the
template is inside a loop (check the Handlebars docs for behavior).

### Shared Helper
Within templates, the `{{shared path}}` helper may be used to run a
JSONpath lookup on the `shared` object in the config file. This will
fetch any value from the shared data, including nested objects.

## Shared Data
The `shared` object in the config file can contain any data that is
shared between multiple transforms. Templates can use the
`{{shared path}}` helper to grab data from this object.

Nested objects and arrays are allowed within the shared object and
work perfectly, since the helper uses JSON path lookups.
